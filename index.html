<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>真 資料結構EX 改</title>

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/solarized.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<section>
						<h1>乂真資結EX改乂</h1>
						<h3>成為十萬序列王</h3>
						<h5>akaiNeko</h5>
					</section>
					<section>
						<h2>whoami</h2>
						<img height="200" width="200" src="https://scontent-tpe1-1.xx.fbcdn.net/hphotos-xat1/v/t1.0-9/11221348_1198872716805403_2087729395243443605_n.jpg?oh=7159874d7ab57f821ddb44439680ddb7&oe=57295774" alt="" />
					</section>
					<section>
						<h2>PECaveros</h2>
						<ul>
							<li>Paul : 數學,小品,字串,DP</li>
							<li>Eddy : 寫code,爆搜,幾何</li>
							<li>我 : 打雜,資結,字串</li>
						</ul>
					</section>
				</section>
				<section>
					<h2>前備知識</h2>
					<ul>
						<li>線段樹與Treap</li>
						<li>線段樹與Treap</li>
						<li>線段樹與Treap</li>
					</ul>
				</section>
				<section>
					<h2>Content</h2>
					<ol>
						<li>更多的Treap</li>
						<li>穿越時空的線段樹與Treap</li>
						<li>擁抱分治，向資結說不</li>
					</ol>
				</section>
				<section>
					<section>
						<h2>Treap 小複習</h2>
						兩種性質 <br>
						兩種操作 <br>
					</section>
					<section>
						<h2>兩種性質</h2>
						<ul>
							<li>堆(Heap)性質：每個點記 pri ，子樹的 pri 都比我小</li>
							<li>樹(Tree)性質：左子樹 key 都比我小，右子樹 key 都比我大</li>
						</ul>
					</section>
					<section>
						<img src="https://docs.google.com/drawings/d/1-TFdaa4pHLqF9N9w18pwYGgFTTbXVbRa5M23fr3bLRc/pub?w=960&h=720" alt="" />
					</section>
					<section>
						<h2>兩種操作</h2>
						<ul>
							<li>
								<code class="c++">merge(Treap *a, Treap *b)</code>
							</li>
							<li>
								<code class="c++">split(Treap *t, int k)</code>
							</li>
						</ul>
					</section>
				</section>
				<section>
					因為 pri 隨機給，高度期望 $O(\log N)$
				</section>
				<section>
					<section id="fragment">
						<h2>找第 k 小</h2>
						<p class="fragment"><tt>std::set</tt>不支援</p>
						<p class="fragment">
							每個節點記個 sz 表示子樹大小
						</p>
						<p class="fragment">
							在二元樹上走一走， $O(\log N)$
						</p>
						<p class="fragment">
							在 <tt>merge, split</tt> 的時候好好重新算
						</p>
					</section>
					<section>
						<h2>看 code</h2>
						<pre>
							<code class="c++">
inline int sz( Treap *t ) {
  return t ? t->sz : 0;
}
int kth( Treap *t , int k ) {
  int lsz = sz( t->l ) + 1;
  if( lsz < k ) return kth( t->r , k - lsz );
  else if( lsz == k ) return t->key;
  else return kth( t->l , k );
}
							</code>
						</pre>
					</section>
					<section>
						<h2>大家都知道的黑魔法</h2>
						<pre>
							<code class="c++">
#include &lt;bits/extc++.h&gt;
using namespace __gnu_pbds;
typedef tree&lt;int,null_type,less&lt;int&gt;
	,rb_tree_tag,tree_order_statistics_node_update&gt; set_t;

int main()
{
  // Insert some entries into s.
  set_t s;
  s.insert(12);
  s.insert(505);

  // The order of the keys should be: 12, 505.
  assert(*s.find_by_order(0) == 12);
  assert(*s.find_by_order(3) == 505);
}
							</code>
						</pre>
					</section>
				</section>
				<section>
					<section id="fragment">
						<h2>Treap as 線段樹</h2>
						<p class="fragment">
							怎麼用 Treap 代表序列？索引值當 key
						</p>
						<p class="fragment">
							節點上在記一個 val 代表 $a_i$
						</p>
					</section>
					<section id="fragment">
						<p class="fragment">
							怎麼紀錄區間的資訊？
						</p>
						<p class="fragment">
							一棵子樹其實就是序列上某個區間
						</p>
						<p class="fragment">
							節點記他子樹（區間）的資訊
						</p>
					</section>
				</section>
				<section>
					<section>
						<h2>Treap 做 RMQ</h2>
						每個點記個 mx ，代表區間最大值 <br>
						問區間 $[l, r]$ 就把 key 在 $[l, r]$ 間的節點 split 出來
					</section>
					<section>
						<pre>
							<code class="c++">
int rmq( Treap *t , int l , int r ) {
  Treap *tl , *tr;
  split( t , l-1 , tl , t );
  split( t , r , t , tr );
  int res = mx( t ); // t 代表 a_l......a_r
  t = merge( merge( tl , t ) , tr );
  return res;
}
							</code>
						</pre>
					</section>
					<section>
						mx 就在 merge, split的時候好好維護
						<pre>
							<code class="c++">
inline void pull( Treap *t ) {
  t->mx = max( mx( t->l ) , max( t->val , mx( t->r ) ) );
}
Treap* merge( Treap *a , Treap *b ) {
  if( !a || !b ) return a ? a : b;
  if( a->pri > b->pri ) {
    a->r = merge( a->r , b );
    pull( a );
    return a;
  } else {
    b->l = merge( a , b->l );
    pull( b );
    return b;
  }
}
							</code>
						</pre>
					</section>
					<section>
						被動到的時候就 pull 一下
						<pre>
							<code>
void split( Treap *t , int x , Treap *&a , Treap *&b ) {
  if( !t ) a = b = NULL;
  else if( t->key <= x ) {
    a = t;
    split( t->r , x , a->r , b );
    pull( a );
  } else {
    b = t;
    split( t->l , x , a , b->l );
    pull( b );
  }
}
							</code>
						</pre>
					</section>
 				</section>
				<section>
					<h2>區間修改呢？</h2>
					跟線段樹一樣用個懶標記就好了
				</section>
				<section>
					<section>
						<h2>EX:動態RMQ</h2>
						兩種操作： <br>
						<ul>
							<li>$a_l, \ldots\ldots, a_r$ 加上 $v$</li>
							<li>問 $a_l, \ldots\ldots, a_r$ 的最大值</li>
						</ul>
					</section>
					<section id="fragment">
						懶標記：每個點記個 add 表示他那個區間要加多少
						<pre>
							<code>
void add( Treap *t , int l , int r , int v ) {
	Treap *tl , *tr;
  split( t , l-1 , tl , t )
  split( t , r , t , tr );
  t->add += v;
  t = merge( merge( tl , t ) , tr );
}
							</code>
						</pre>
					</section>
					<section>
						要動到子樹前記得把標記往下 push
						<pre>
							<code>
void push( Treap *t ) {
  t->val += t->add;
  if( t->l ) t->l->add += t->add;
  if( t->r ) t->r->add += t->add;
  t->add = 0;
}
							</code>
						</pre>
					</section>
				</section>
				<section>
					<section>
						<h2>真的要存 key 嗎？</h2>
						其實 key 只是代表我比多少人大 <br>
						那不就是 rank ，存子樹大小就好 <br>
					</section>
					<section>
						<img src="http://i.imgur.com/OGa2nP6.png" alt="" />
					</section>
				</section>
				<section>
					<h2>坐上時光機囉</h2>
					<img src="https://qobzrg.bn1.livefilestore.com/y1mJoftKpOYUTXglUrJLC6Jn4_L2W0MXGOoTAdAU6SEBPNBvJThWTqaogSazd9pZRHNgsIK9LCtYII-yCiOps8Wu9wuS3hMyw_h-XQX78igwWCTokb5u3M06A/%E6%97%B6%E5%85%89%E6%97%85%E8%A1%8C.jpg?psid=1" alt="" />
				</section>
				<section>
					<h2>EX:UVA 12538</h2>
					實作資料結構支援 <br>
					<ul>
						<li>把字串 $s$ 插在第 $p$ 個字後面</li>
						<li>把第 $p$ 個字後面 $c$ 個字砍掉</li>
						<li>印出第 $v$ 個版本第 $p$ 個字後面 $c$ 個字</li>
					</ul>
				</section>
				<section>
					不問過去版本的話是 Treap 亂做水題 <br>
					莫非每個版本做一棵新的 Treap？ $a+b$ <br>
					可持久化它？！？！？！
				</section>
				<section>
					<section>
						<h1>YES</h1>
						但是不用複製整顆 Treap <br>
						Copy-On-Write，改到再複製
					</section>
					<section>
						<img src="img/persistent-tree.jpg" alt="" />
					</section>
					<section>
						因為 merge, split 也最多動到 $O(\log N)$ 個點 <br>
						空間 $O(N \log N)$
					</section>
					<section>
						<h2>看看 code</h2>
						<pre>
							<code class="c++">
Node* merge( Node *a , Node *b ) {
  if( !a || !b ) return a ? a : b;
  Node *res;
// !?!?!?!?
  if( myRnd() % ( sz( a ) + sz( b ) ) < sz( a ) ) {
    res = new Node( *a );
    res->r = merge( a->r , b );
  }
  else {
    res = new ( ptr++ ) Node( *b );
    res->l = merge( a , b->l );
  }
  pull( res );
  return res;
}
							</code>
						</pre>
					</section>
					<section>
						<pre>
							<code class="c++">
void split( Node *t , int k , Node *&a , Node *&b ) {
  if( !t ) a = b = NULL;
  else if( sz( t->l ) + 1 <= k ) {
    a = new Node( *t );
    split( t->r , k-1-sz(t->l) , a->r , b );
    pull( a );
  }
  else {
    b = new ( ptr++ ) Node( *t );
    split( t->l , k , a , b->l );
    pull( b );
  }
}
							</code>
						</pre>
					</section>
					<section>
						<h2>連 pri 都不用記了？！？！</h2>
						可以這樣想： <br>
						兩顆樹 a, b， <br>
						最大的 pri 出現在 a 的機率 $= \frac{size(a)}{size(a)+size(b)}$
					</section>
				</section>
				<section>
          <h2>當可持久遇上線段樹</h2>
          一樣是動到哪裡複製哪裡 <br>
          <tt>x, 2x, 2x+1</tt>型線段樹會壞掉
				</section>
        <section>
          <h2>EX:區間第 k 小</h2>
          序列 $a_1,\ldots\ldots,a_N, 1 \le a_i \le N$ <br>
          每次問區間 $[l, r]$ 裡第 k 小是誰
        </section>
        <section>
          <section>
            <h2>小時候作法</h2>
            <tt>vector</tt> 套線段樹佐二分搜 $O(Q \log^3 N)$ <br>
            有更好的複雜度嗎？QQ
          </section>
          <section>
            <h2>線段樹 as 平衡樹</h2>
            以數值當 index <br>
            用線段樹維護數值區間總出現次數 <br>
            在樹上走來走去就好
          </section>
          <section>
            <h2>想想可持久</h2>
            依序把 $a_1,a_2,\ldots\ldots,a_n$ 插入 <br>
            維護每次插入的版本 $s_i$ (插入 $a_1,a_2,\ldots\ldots,a_i$ 後的樹)
          </section>
          <section>
            <h2>$[1,r]$ 式詢問勝利</h2>
            直接查 $s_r$
          </section>
          <section>
            <h2>$[l, r]$ 式詢問勝利</h2>
            因為線段樹結構固定 <br>
            $s_{l-1}, s_r$ 相對應節點上的和相減就是插入 $[l, r]$ 的樣子 <br>
            同時在兩棵樹走 $O(\log N)$ 勝利
          </section>
        </section>
        <section>
          <section>
            <h2>BIT</h2>
            翻轉教室，自己讀 <br>
          </section>
          <section>
            好寫
          </section>
          <section>
            單點加值
          </section>
          <section>
            問前綴和
          </section>
        </section>
        <section>
          <h2>Why 離線?</h2>
          <ul>
            <li>在線作法不好做</li>
            <li>在線太久太滿</li>
          </ul>
        </section>
        <section>
          <section>
            <h1>整體二分</h1>
          </section>
          <section>
            要二分搜的太多了 <br>
            大家一起來共用檢查時算出的資訊吧
          </section>
        </section>
        <section>
          <section>
            <h2>Meteor</h2>
            長度 $M$ 的序列，一開始都是0 <br>
            $N$ 個人瓜分這個序列，每個人有他的目標 $g_i$ <br>
            $K$ 次操作，每次都是序列某個區間全部加上 $x_i > 0$ <br>
            問每個人什麼時候達到目標 <br>
            也就是擁有的元素加起來 $\ge g_i$
          </section>
          <section>
            每個人二分搜啥時好字 <br>
            用可持久線段樹維護每個操作做完的序列長相
          </section>
          <section>
            時間 $O((M+N) \log K \log M)$ <br>
            空間 $O(K \log M)$
          </section>
          <section>
            <h1 style="color:red;">MLE</h1>
            mempry limit: 64 mb
          </section>
        </section>
        <section>
          <section>
            開 $K$ 棵線段樹真的太虧了 <br>
            看來不能每個人各自二分搜了
          </section>
          <section>
            那也只好大家一起二分搜了
            <pre>
              <code>
typedef vector&lt; int &gt; VI;
void totBS( int s , int e , VI nation ) {
  if(s > e || nation.size() == 0)
    return ;
  int mid = (s + e) / 2;

  do_things( s , mid );

  VI ok, notok;
  split( mid , nation , ok , notok );

  undo_things( s , mid );

  totBS( s , mid-1 , ok );
  totBS( mid+1 , e , notok );
}
              </code>
            </pre>
          </section>
          <section>
            看那些人可以在 <tt>mid</tt> 之前達到目標 <br>
            可以的丟去二分搜 $[s, mid-1]$ <br>
            不行的丟去二分搜 $[mid+1, e]$
          </section>
          <section>
            把 $[s,mid]$ 的操作作用一番 <br>
            BIT 維護之
            <pre>
              <code>
void do_things( int s , int mid ) {
  for( int i = s ; i <= mid ; i++ ) {
    int nl = in[ i ].l , nr = in[ i ].r;
    ll nnu = in[ i ].nu;
    bit.upd(nl, nnu);
    bit.upd(nr+1, -nnu);
  }
}
              </code>
            </pre>
          </section>
          <section>
            看那些人在 <tt>mid</tt> 前可以被滿足 <br>
            並且更新他們的目標 (把 $[s, mid]$ 對他們貢獻扣掉)
            <pre>
              <code>
void split( int mid , VI& nation , VI& ok , VI& notok ) {
  for( int nat : nation ) {
    tem[nat] = 0ll;
    for( int it : satel[ nat ] ) {
      tem[nat] += bit.qry(it);
      if(tem[nat] >= need[nat])
        break;
    }
    if(tem[nat] >= need[nat]) {
      ok.push_back(nat);
      if(ans[nat] > 0) ans[nat] = min(ans[nat], mid);
      else ans[nat] = mid;
    }
    else {
      need[nat] -= tem[nat];
      notok.push_back(nat);
    }
  }
  // 真的把 nation 佔的記憶體釋放掉
  VI ().swap( nation );
}
              </code>
            </pre>
          </section>
          <section>
            把 BIT 還原 <br>
            還給子孫乾淨的 BIT
            <pre>
              <code>
void undo_things( int s , int mid ) {
  for(int i = s; i <= mid; i++) {
    int nl = in[i].l, nr = in[i].r;
    ll nnu = in[i].nu;
    bit.upd(nl, -nnu);
    bit.upd(nr+1, nnu);
  }
}
              </code>
            </pre>
          </section>
          <section>
            時間： $O((N+M+K)\log M \log K)$ <br>
            空間： $O(M)$ (這寫法空間真的是線性嗎^^)
          </section>
          <section>
            <h1 style="color:green;">AC</h1>
            其實這作法好好寫可以不用 BIT <br>
            時間少一個 $O(\log M)$ <br>
            空間也是好好線性
          </section>
        </section>
        <section>
          <section>
            <h1>操作分治</h1>
          </section>
          <section>
            在線好難做 <br>
            把操作們整理成方便處理的順序 <br>
            變得好做
          </section>
        </section>
        <section>
          <section>
            <h2>Machine works</h2>
            給你 $N, t_i, g_i, r_i, p_i$ <br>
            $N \le 10^5$, $t_i$ 遞增 <br>
            計算下列 DP 式 : <br>
            $dp[i] = \max_{j < i}\{ g_j t_i + (r_j - p_j + dp[j] - (t_j+1)g_j) \}$
          </section>
          <section>
            阿不就斜率優化 DP <br>
            deque 做過去就沒啦
          </section>
          <section>
            可是 $g_j$ 沒有單調性 <br>
            <h2 style="color:red;">慘</h2>
          </section>
          <section>
            用平衡樹維護下凸包 <br>
            算好一個 $dp[i]$ 後 <br>
            把 $y = g_i x + (r_j - p_j + dp[i] - (t_j+1)g_j)$ 塞進去 <br>
            把附近斜率不必要的線拔掉 <br>
            一堆邊界條件好難寫
          </section>
          <section>
            <h2>好希望 $g_j$ 有單調性阿~~</h2>
          </section>
          <section>
            <h3>想想分治</h3>
            先把 $dp[1\ldots\frac{N}{2}]$ 做完 <br>
            按照 $g_j$ 排好 <br>
            那就可以輕鬆做 $dp[\frac{N}{2}+1\ldots N]$ 了耶 <br>
          </section>
          <section>
            所以可以得到長這樣的作法
            <pre>
              <code class="c++">
void solve( int l , int r ) {
  if( l == r ) return ;
  int mid = ( l + r ) / 2;
  solve( l , mid );
  // 把 [l, mid] 整理好
  // 算 [l, mid] 對 [mid+1, r] 答案的影響
  solve( mid+1 , r );
}
              </code>
            </pre>
          </section>
          <section>
            整理好就只是 <br>
            先把線做出來，排序好
            <pre>
              <code class="c++">
vector&lt; Line &gt; lns , stk;
lns.clear();
for( int i = l ; i <= mid ; i++ )
  if( in[ i ].dp >= in[ i ].P ) {
    Ln l1{
      in[ i ].G ,
      in[ i ].dp-in[ i ].P+in[ i ].R
      -( in[ i ].D+1ll )*in[ i ].G
    };
    lns.push_back( l1 );
  }
sort( lns.begin() , lns.end() );
              </code>
            </pre>
          </section>
          <section>
            然後做出下凸包，把不必要的線拿走
            <pre>
              <code class="c++">
stk.clear();
for( Ln l1 : lns ) {
  while( stk.size()
      && stk.back().m == l1.m
      && stk.back().b < l1.b )
    stk.pop_back();
  if( stk.size() && stk.back().m == l1.m ) continue ;
  while( stk.size() >= 2
      && !ok( stk[ stk.size() - 2 ] ,
              stk[ stk.size() - 1 ] , l1 ) )
    stk.pop_back();
  stk.push_back( l1 );
}
              </code>
            </pre>
          </section>
          <section>
            <h2>不必要的線？</h2>
            像圖中紅色的線就是爛線 <br>
            <img width="480" height="360" src="https://docs.google.com/drawings/d/1BqjjxB_vTFAIWztaMp5fjLpv2UDXwFTjM7JnaRZRDtU/pub?w=960&h=720" alt="" />
          </section>
          <section>
            接下來就是要去更新 $[mid+1, r]$ 的 dp 值了 <br>
            <pre>
              <code class="c++">
int j = 0;
for( int i = mid+1 ; i <= r ; i++ ) {
  ll x = in[ i ].D;
  while( j + 1 < (int)stk.size()
      && stk[ j ]( x ) < stk[ j+1 ]( x ) )
    j++;
  in[ i ].dp = max( in[ i ].dp , stk[ j ]( x ) );
}
dq( mid + 1 , r );
              </code>
            </pre>
          </section>
          <section>
            這裡只處理 $[l, mid]$ 對 $dp[i]$ 的影響 <br>
            $[mid+1, i-1]$ 的影響透過 <tt>dq(mid+1, r)</tt> 遞迴搞定
          </section>
          <section>
            <h2>j 是來幹嘛的</h2>
            隨著 $t_i$ 遞增，讓 $m \times t_i + b$ 最大的 $m$ 會遞增 <br>
            <img src="https://docs.google.com/drawings/d/1FpZLaTbC1ohYQJHsEvcEiykc-yp8eV2sSQ1lEDbe5bc/pub?w=480&h=360" alt="" />
          </section>
          <section>
            好好 merge sort 線的斜率的話 <br>
            時間 : $O(N \log N)$
          </section>
        </section>
        <section>
          <h1>例題們</h1>
        </section>

        <section>
          <section>
            <h1>Cup trick</h1>
          </section>
          <section>
            Treap 維護序列，節點記原始位置與上面貼紙數字 (一開始為未知) <br>
            每次移動就可以確定一個節點貼紙是啥
          </section>
        </section>

        <section>
          <section>
            <h1>Peaks</h1>
          </section>
          <section>
            用 Treap 維護連通塊，以點權做 key <br>
            把邊照邊權由小到大排序 <br>
            把詢問離線，按照小到大慢慢把邊加進來 <br>
            啟發式合併兩個連通塊，然後找第 k 小
          </section>
        </section>

        <section>
          <section>
            <h1>蚯蚯扭扭</h1>
          </section>
          <section>
            用 Copy-on-write Treap 維護字串 <br>
            反轉的 tag 要小心 push
          </section>
        </section>

        <section>
          <section>
            <h1>子矩陣第 k 小</h1>
          </section>
          <section>
            整體二分 <br>
            看每個詢問的子矩陣裡有多少 $\le mid$ <br>
            所以用二維 BIT 維護子矩陣裡 $\le mid$ 個數
          </section>
        </section>

        <section>
          <section>
            <h1>動態區間第 k 小</h1>
          </section>
          <section>
            <h2>法1</h2>
            BIT 套 可持久線段樹 <br>
            <tt>root[i]</tt> 代表 $(i-lowbit(i), i]$ 做出來的線段樹 <br>
            更新就動那 $O(\log N)$ 棵線段樹 <br>
            查詢就同時走 $O(\log N)$ 棵線段樹
          </section>
          <section>
            <h2>法2</h2>
            整體二分 <br>
            對於每個區間看裏面多少 $\le mid$ <br>
            因為有修改，所以值有保存日期 (區間) <br>
            所以一個值除了位置還有存活期間要紀錄 <br>
            拆成進入跟離開然後跟詢問依起排序之後掃過去 <br>
            用 BIT 維護區間 $\le mid$ 個數
          </section>
        </section>

        <section>
          <section>
            <h1>D-QUERY(在線)</h1>
          </section>
          <section>
            用可持久線段樹 $s_r$ 記 $a_1,\ldots,a_r$ 裡最後一次出現 $i$ 有幾種數字 <br>
            對於詢問 $[l, r]$ 就是 $s_r$ 裡最後一次出現在 $[l, r]$ 裡的有幾種 <br>
            就 $s_r$ 上 $[l, r]$ 的和就是了
          </section>
        </section>

        <section>
          <section>
            <h1>動態逆序對</h1>
          </section>
          <section>
            操作分治 <br>
            第 $k$ 次刪除 $a_i$ 少掉的逆序對就是： <br>
            <ul>
              <li>前大：原始序列裡在他前面比他大 (BIT 預處理)</li>
              <li>後小：在他後面比他小 (BIT 預處理)</li>
            </ul> <br>
            但要加回來第 $1 \sim k-1$ 次刪除裡符合前兩項條件的 <br>
          </section>
          <section>
            用操作分治算每次刪除要加回來多少 <br>
            對位置雙指針 <br>
            用 BIT 維護第 $l \sim mid$ 次刪除裡 $> a_i$ 的有幾個 <br>
            然後反過來再做一次 (算後小)
          </section>
        </section>

        <section>
          <section>
            <h1>總結</h1>
          </section>
          <section>
            <ul>
              <li>Treap as 線段樹</li>
              <li>Copy on write 維護歷史版本</li>
              <li>分治想法解決資料結構題</li>
            </ul>
          </section>
        </section>
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,
        slideNumber: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true },
					// MathJax
        	{ src: 'plugin/math/math.js', async: true }
				]
			});

		</script>

	</body>
</html>
